// hooks/usePusher.ts
import { useEffect, useRef, useState, useCallback } from 'react';
import Pusher from 'pusher-js';
import { Message, User, ConnectionStatus, TypingUser, NotificationSettings } from '@/types/chat';
import { getPusherInstance, releasePusherInstance, getPusherStatus } from '@/lib/pusher-singleton';

export const usePusher = () => {
  const [isConnected, setIsConnected] = useState(false);
  const [connectionStatus, setConnectionStatus] = useState<ConnectionStatus>('connecting');
  const [onlineUsers, setOnlineUsers] = useState<User[]>([]);
  const [messages, setMessages] = useState<Message[]>([]);
  const [retryCount, setRetryCount] = useState(0);
  const [lastError, setLastError] = useState<string | null>(null);
  const [typingUsers, setTypingUsers] = useState<TypingUser[]>([]);
  const [notificationSettings, setNotificationSettings] = useState<NotificationSettings>(() => {
    // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú ÏÑ§Ï†ï Î∂àÎü¨Ïò§Í∏∞
    if (typeof window !== 'undefined') {
      try {
        const saved = localStorage.getItem('chatNotificationSettings');
        if (saved) {
          return JSON.parse(saved);
        }
      } catch (error) {
        console.warn('Failed to load notification settings:', error);
      }
    }
    
    // Í∏∞Î≥∏Í∞í
    return {
      sound: true,
      desktop: true,
      typing: true,
    };
  });

  const pusherRef = useRef<InstanceType<typeof Pusher> | null>(null);
  const channelRef = useRef<ReturnType<Pusher['subscribe']> | null>(null);
  const reconnectTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const heartbeatIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const syncIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const connectionCheckIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const isDisconnectingRef = useRef<boolean>(false);
  const connectionAttemptsRef = useRef<number>(0);
  const isInitializedRef = useRef<boolean>(false);
  const componentMountedRef = useRef<boolean>(false);
  const currentUserRef = useRef<User | null>(null);
  const typingTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);
  const typingCleanupIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);
  const isTypingRef = useRef<boolean>(false);
  const maxRetries = process.env.NODE_ENV === 'production' ? 8 : 5;
  const retryDelay = process.env.NODE_ENV === 'production' ? 3000 : 2000;
  const heartbeatInterval = 45000; // 45Ï¥à
  const syncInterval = 90000; // 1.5Î∂Ñ
  const connectionCheckInterval = process.env.NODE_ENV === 'production' ? 10000 : 5000; // ÌîÑÎ°úÎçïÏÖòÏóêÏÑúÎäî 10Ï¥à

  // Ï§ëÎ≥µ ÏÇ¨Ïö©Ïûê Ï≤¥ÌÅ¨ Ìï®Ïàò
  const isUserAlreadyOnline = useCallback((userId: string) => {
    const isOnline = onlineUsers.some(user => user.id === userId);
    console.log(`üîç Checking if user ${userId} is already online:`, isOnline);
    console.log('üë• Current online users:', onlineUsers.map(u => ({ id: u.id, name: u.name })));
    return isOnline;
  }, [onlineUsers]);

  // Pusher Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏
  const isPusherConnected = useCallback(() => {
    return pusherRef.current && 
           pusherRef.current.connection.state === 'connected' && 
           !isDisconnectingRef.current;
  }, []);

  // Ïó∞Í≤∞ ÏÉÅÌÉú ÏÉÅÏÑ∏ Ï†ïÎ≥¥ Í∞ÄÏ†∏Ïò§Í∏∞
  const getConnectionState = useCallback(() => {
    if (!pusherRef.current) return 'disconnected';
    return pusherRef.current.connection.state;
  }, []);

  // ÌòÑÏû¨ Ï†ÑÏÜ° Î∞©Ïãù Í∞ÄÏ†∏Ïò§Í∏∞
  const getCurrentTransport = useCallback(() => {
    if (!pusherRef.current) return null;
    return pusherRef.current.connection.state;
  }, []);

  // ÏÑúÎ≤ÑÏóêÏÑú ÌôúÏÑ± ÏÇ¨Ïö©Ïûê Î™©Î°ù Í∞ÄÏ†∏Ïò§Í∏∞
  const syncWithServer = useCallback(async () => {
    try {
      console.log('üîÑ Syncing with server...');
      const response = await fetch('/api/pusher/user');
      if (response.ok) {
        const data = await response.json();
        if (data.success && data.activeUsers) {
          console.log('üîÑ Server sync - active users:', data.activeUsers.length);
          
          // ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÎ•º Ï†úÏô∏Ìïú Îã§Î•∏ ÏÇ¨Ïö©ÏûêÎì§Îßå ÌïÑÌÑ∞ÎßÅ
          const currentUserId = currentUserRef.current?.id;
          const serverUsers = data.activeUsers.filter((user: User) => user.id !== currentUserId);
          
          // Î°úÏª¨ ÏÉÅÌÉúÏôÄ ÏÑúÎ≤Ñ ÏÉÅÌÉú ÎπÑÍµê Î∞è ÏóÖÎç∞Ïù¥Ìä∏
          setOnlineUsers(prev => {
            const localUserIds = new Set(prev.map(u => u.id));
            const serverUserIds = new Set(serverUsers.map((u: User) => u.id));
            
            // ÏÑúÎ≤ÑÏóêÎßå ÏûàÎäî ÏÇ¨Ïö©ÏûêÎì§ Ï∂îÍ∞Ä
            const usersToAdd = serverUsers.filter((u: User) => !localUserIds.has(u.id));
            
            // Î°úÏª¨ÏóêÎßå ÏûàÎäî ÏÇ¨Ïö©ÏûêÎì§ Ï†úÍ±∞
            const usersToKeep = prev.filter(u => serverUserIds.has(u.id) || u.id === currentUserId);
            
            const newUsers = [...usersToKeep, ...usersToAdd];
            
            if (usersToAdd.length > 0 || prev.length !== usersToKeep.length) {
              console.log('üîÑ Updated online users from server sync');
              console.log('  - Added:', usersToAdd.length, 'users');
              console.log('  - Removed:', prev.length - usersToKeep.length, 'users');
              console.log('  - Total online:', newUsers.length);
            }
            
            return newUsers;
          });
        }
      }
    } catch (error) {
      console.error('Error syncing with server:', error);
    }
  }, []);

  // ÌïòÌä∏ÎπÑÌä∏ Ï†ÑÏÜ°
  const sendHeartbeat = useCallback(async () => {
    if (!currentUserRef.current || !isConnected) return;
    
    try {
      await fetch('/api/pusher/user', {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ userId: currentUserRef.current.id }),
      });
    } catch (error) {
      console.error('Error sending heartbeat:', error);
    }
  }, [isConnected]);

  // Ïó∞Í≤∞ ÏÉÅÌÉú Ïã§ÏãúÍ∞Ñ ÌôïÏù∏
  const checkConnectionStatus = useCallback(() => {
    if (!pusherRef.current) return;
    
    const actualState = pusherRef.current.connection.state;
    console.log('üîç Real-time connection check:', {
      actualPusherState: actualState,
      localIsConnected: isConnected,
      localConnectionStatus: connectionStatus
    });
    
    // Ïã§Ï†ú Pusher ÏÉÅÌÉúÏôÄ Î°úÏª¨ ÏÉÅÌÉúÍ∞Ä Îã§Î•∏ Í≤ΩÏö∞ ÎèôÍ∏∞Ìôî
    if (actualState === 'connected' && (!isConnected || connectionStatus !== 'connected')) {
      console.log('‚ö° Fixing connection status: actualState=connected but local state incorrect');
      setConnectionStatus('connected');
      setIsConnected(true);
      setRetryCount(0);
      setLastError(null);
      connectionAttemptsRef.current = 0;
      isDisconnectingRef.current = false;
      
      // Ïó∞Í≤∞Îêú ÏÉÅÌÉúÏóêÏÑú Ï£ºÍ∏∞Ï†Å ÏûëÏóÖÏù¥ Ï§ëÏßÄÎêòÏñ¥ ÏûàÎã§Î©¥ ÏãúÏûë
      if (!heartbeatIntervalRef.current || !syncIntervalRef.current) {
        startPeriodicTasks();
        setTimeout(syncWithServer, 1000);
      }
    } else if (actualState === 'connecting' && connectionStatus !== 'connecting') {
      console.log('‚ö° Fixing connection status: actualState=connecting');
      setConnectionStatus('connecting');
      setLastError(null);
    } else if (actualState === 'disconnected' && isConnected) {
      console.log('‚ö° Fixing connection status: actualState=disconnected but local isConnected=true');
      setConnectionStatus('disconnected');
      setIsConnected(false);
      stopPeriodicTasks();
    } else if (actualState === 'failed' && connectionStatus !== 'failed') {
      console.log('‚ö° Fixing connection status: actualState=failed');
      setConnectionStatus('failed');
      setIsConnected(false);
      stopPeriodicTasks();
    }
  }, [isConnected, connectionStatus, syncWithServer]);

  // ÌïòÌä∏ÎπÑÌä∏ Î∞è ÎèôÍ∏∞Ìôî ÏãúÏûë
  const startPeriodicTasks = useCallback(() => {
    // ÌïòÌä∏ÎπÑÌä∏ ÌÉÄÏù¥Î®∏
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
    }
    heartbeatIntervalRef.current = setInterval(() => {
      if (isConnected && currentUserRef.current) {
        sendHeartbeat();
      }
    }, heartbeatInterval);

    // ÎèôÍ∏∞Ìôî ÌÉÄÏù¥Î®∏
    if (syncIntervalRef.current) {
      clearInterval(syncIntervalRef.current);
    }
    syncIntervalRef.current = setInterval(() => {
      if (isConnected) {
        syncWithServer();
      }
    }, syncInterval);

    // Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏ ÌÉÄÏù¥Î®∏
    if (connectionCheckIntervalRef.current) {
      clearInterval(connectionCheckIntervalRef.current);
    }
    connectionCheckIntervalRef.current = setInterval(() => {
      checkConnectionStatus();
    }, connectionCheckInterval);
    
    console.log('üöÄ Started all periodic tasks (heartbeat, sync, connection check)');
  }, [isConnected, sendHeartbeat, syncWithServer, checkConnectionStatus]);

  // Ï£ºÍ∏∞Ï†Å ÏûëÏóÖ Ï§ëÏßÄ
  const stopPeriodicTasks = useCallback(() => {
    if (heartbeatIntervalRef.current) {
      clearInterval(heartbeatIntervalRef.current);
      heartbeatIntervalRef.current = null;
    }
    if (syncIntervalRef.current) {
      clearInterval(syncIntervalRef.current);
      syncIntervalRef.current = null;
    }
    if (connectionCheckIntervalRef.current) {
      clearInterval(connectionCheckIntervalRef.current);
      connectionCheckIntervalRef.current = null;
    }
  }, []);

  // Ïó∞Í≤∞ ÏÉÅÌÉú Î°úÍπÖ Ìï®Ïàò (Îçî ÏÉÅÏÑ∏Ìïú Ï†ïÎ≥¥ Ìè¨Ìï®)
  const logConnectionState = useCallback((state: string, details?: string) => {
    const timestamp = new Date().toLocaleTimeString();
    const isDisconnecting = isDisconnectingRef.current;
    const connectionState = pusherRef.current?.connection.state || 'unknown';
    const attemptCount = connectionAttemptsRef.current;
    const isInitialized = isInitializedRef.current;
    const componentMounted = componentMountedRef.current;
    const hasPusherInstance = !!pusherRef.current;
    
    console.log(`[${timestamp}] Pusher Connection: ${state}${details ? ` - ${details}` : ''} | State: ${connectionState} | Disconnecting: ${isDisconnecting} | Attempt: ${attemptCount} | Initialized: ${isInitialized} | Mounted: ${componentMounted} | HasInstance: ${hasPusherInstance}`);
  }, []);

  // Pusher Ï¥àÍ∏∞Ìôî Ìï®Ïàò (Ïã±Í∏ÄÌÜ§ ÏÇ¨Ïö©)
  const initializePusher = useCallback(() => {
    try {
      logConnectionState('initialize_start', 'function called');
      
      // Ïª¥Ìè¨ÎÑåÌä∏Í∞Ä ÎßàÏö¥Ìä∏ÎêòÏßÄ ÏïäÏïòÏúºÎ©¥ Ïä§ÌÇµ
      if (!componentMountedRef.current) {
        logConnectionState('initialize_skipped', 'component not mounted');
        return;
      }

      // Ïù¥ÎØ∏ Ï¥àÍ∏∞ÌôîÎêòÏóàÍ±∞ÎÇò Ïó∞Í≤∞ Ìï¥Ï†ú Ï§ëÏù¥Î©¥ Ïä§ÌÇµ
      if (isInitializedRef.current || isDisconnectingRef.current) {
        logConnectionState('initialize_skipped', `already initialized: ${isInitializedRef.current}, disconnecting: ${isDisconnectingRef.current}`);
        return;
      }

      setConnectionStatus('connecting');
      setLastError(null);
      connectionAttemptsRef.current++;
      
      logConnectionState('initializing', `attempt ${connectionAttemptsRef.current}`);
      
      // Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§ Í∞ÄÏ†∏Ïò§Í∏∞
      const instance = getPusherInstance();
      if (!instance) {
        logConnectionState('initialize_failed', 'failed to get pusher instance');
        setConnectionStatus('failed');
        setLastError('Failed to initialize Pusher');
        return;
      }

      const { pusher, channel, isReused } = instance;
      pusherRef.current = pusher;
      channelRef.current = channel;
      isInitializedRef.current = true;

      logConnectionState('pusher_instance_obtained', `singleton instance obtained successfully (reused: ${isReused})`);

      // Í∏∞Ï°¥ Ïó∞Í≤∞ ÏÉÅÌÉú ÌôïÏù∏ Î∞è ÏÑ§Ï†ï (Í∞ïÌôîÎêú Î≤ÑÏ†Ñ)
      const currentState = pusher.connection.state;
      console.log('üîç Current connection state:', currentState);
      
      if (currentState === 'connected') {
        setConnectionStatus('connected');
        setIsConnected(true);
        setRetryCount(0);
        setLastError(null);
        connectionAttemptsRef.current = 0;
        isDisconnectingRef.current = false;
        logConnectionState('connection_state_sync', 'synced with existing connected state');
        
        // Ïó∞Í≤∞Îêú ÏÉÅÌÉúÎ©¥ Ï¶âÏãú Ï£ºÍ∏∞Ï†Å ÏûëÏóÖ ÏãúÏûë
        setTimeout(() => {
          startPeriodicTasks();
          syncWithServer();
        }, 500);
      } else if (currentState === 'connecting') {
        setConnectionStatus('connecting');
        setIsConnected(false);
        logConnectionState('connection_state_sync', 'synced with existing connecting state');
      } else {
        setConnectionStatus('disconnected');
        setIsConnected(false);
        logConnectionState('connection_state_sync', 'synced with existing disconnected state');
      }

      // Ïû¨ÏÇ¨Ïö©Îêú Ïù∏Ïä§ÌÑ¥Ïä§Ïùò Í≤ΩÏö∞ Ïù¥Î≤§Ìä∏ Î∞îÏù∏Îî©ÏùÑ Í±¥ÎÑàÎõ∞Í≥†, ÏÉà Ïù∏Ïä§ÌÑ¥Ïä§Îßå Î∞îÏù∏Îî©
      if (!isReused) {
        console.log('üéØ Binding events to new instance');
        // Ïó∞Í≤∞ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ
      pusher.connection.bind('connecting', () => {
        logConnectionState('connecting_event', 'event triggered');
        setConnectionStatus('connecting');
        setLastError(null);
      });

      pusher.connection.bind('connected', () => {
        logConnectionState('connected_event', 'event triggered - successfully');
        setConnectionStatus('connected');
        setIsConnected(true);
        setRetryCount(0);
        setLastError(null);
        connectionAttemptsRef.current = 0;
        isDisconnectingRef.current = false;
        
        // Ïó∞Í≤∞ÎêòÎ©¥ Ï£ºÍ∏∞Ï†Å ÏûëÏóÖ ÏãúÏûë Î∞è ÏÑúÎ≤ÑÏôÄ ÎèôÍ∏∞Ìôî
        startPeriodicTasks();
        setTimeout(syncWithServer, 1000); // 1Ï¥à ÌõÑ ÏÑúÎ≤ÑÏôÄ ÎèôÍ∏∞Ìôî
      });

      pusher.connection.bind('disconnected', () => {
        logConnectionState('disconnected_event', 'event triggered');
        setConnectionStatus('disconnected');
        setIsConnected(false);
        
        // Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥ÏßÄÎ©¥ Ï£ºÍ∏∞Ï†Å ÏûëÏóÖ Ï§ëÏßÄ
        stopPeriodicTasks();
        
        // ÏàòÎèôÏúºÎ°ú Ìï¥Ï†úÌïú Í≤ÉÏù¥ ÏïÑÎãê ÎïåÎßå ÏûêÎèô Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
        if (!isDisconnectingRef.current && connectionAttemptsRef.current < maxRetries) {
          logConnectionState('auto_reconnect', 'attempting automatic reconnection');
          attemptReconnect();
        } else if (connectionAttemptsRef.current >= maxRetries) {
          logConnectionState('max_retries', 'reached, stopping auto-reconnect');
          setConnectionStatus('failed');
          setLastError('Max reconnection attempts reached');
        }
      });

      pusher.connection.bind('failed', () => {
        logConnectionState('failed_event', 'event triggered');
        setConnectionStatus('failed');
        setIsConnected(false);
        setLastError('Connection failed');
        
        // ÏàòÎèôÏúºÎ°ú Ìï¥Ï†úÌïú Í≤ÉÏù¥ ÏïÑÎãê ÎïåÎßå Ïû¨Ïó∞Í≤∞ ÏãúÎèÑ
        if (!isDisconnectingRef.current && connectionAttemptsRef.current < maxRetries) {
          logConnectionState('reconnect_after_failure');
          attemptReconnect();
        }
      });

      pusher.connection.bind('error', (error: any) => {
        const errorMsg = error.message || error.type || 'Unknown error';
        logConnectionState('error_event', `event triggered - ${errorMsg}`);
        setLastError(errorMsg);
      });

      // Ïó∞Í≤∞ ÏÉÅÌÉú Î≥ÄÍ≤Ω Í∞êÏßÄ
      pusher.connection.bind('state_change', (states: { previous: string; current: string }) => {
        logConnectionState('state_change', `${states.previous} ‚Üí ${states.current}`);
        
        if (states.current === 'connected') {
          setConnectionStatus('connected');
          setIsConnected(true);
          isDisconnectingRef.current = false;
          startPeriodicTasks();
          setTimeout(syncWithServer, 1000);
        } else if (states.current === 'disconnected') {
          setConnectionStatus('disconnected');
          setIsConnected(false);
          stopPeriodicTasks();
        } else if (states.current === 'connecting') {
          setConnectionStatus('connecting');
        } else if (states.current === 'failed') {
          setConnectionStatus('failed');
          stopPeriodicTasks();
        }
      });

      logConnectionState('channel_ready', 'chat channel ready from singleton');

      // Ï±ÑÎÑê Íµ¨ÎèÖ ÏÑ±Í≥µ Ïù¥Î≤§Ìä∏
      channel.bind('pusher:subscription_succeeded', () => {
        logConnectionState('subscription_succeeded', 'channel subscription confirmed');
      });

      // Ï±ÑÎÑê Íµ¨ÎèÖ ÏóêÎü¨ Ïù¥Î≤§Ìä∏
      channel.bind('pusher:subscription_error', (error: any) => {
        logConnectionState('subscription_error', `channel subscription failed: ${error.message || 'unknown error'}`);
        setLastError('Channel subscription failed');
      });

      // Î©îÏãúÏßÄ ÏàòÏã†
      channel.bind('new-message', (message: Message) => {
        console.log('üì® Raw message received:', message);
        logConnectionState('message_received', `new message from ${message.userName}`);
        
        // ÏóêÎü¨ Î©îÏãúÏßÄÏù∏ÏßÄ ÌôïÏù∏ÌïòÏó¨ ÌïÑÌÑ∞ÎßÅ
        const isErrorMessage = message.text && (
          message.text.includes('Application error:') ||
          message.text.includes('client-side exception') ||
          message.text.includes('Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§') ||
          message.text.includes('ÏóêÎü¨') ||
          message.text.includes('Error:') ||
          message.text.includes('Failed to')
        );
        
        if (isErrorMessage) {
          console.warn('‚ö†Ô∏è Filtering out error message from display:', {
            messageId: message.id,
            text: message.text.substring(0, 100),
            userId: message.userId,
            userName: message.userName
          });
          
          // ÏóêÎü¨ Î©îÏãúÏßÄÎäî Ï±ÑÌåÖ Î™©Î°ùÏóê Ï∂îÍ∞ÄÌïòÏßÄ ÏïäÏùå
          return;
        }
        
        setMessages(prev => {
          // Îã§Ï§ë Ï°∞Í±¥ÏúºÎ°ú Ï§ëÎ≥µ ÌôïÏù∏
          const isDuplicateById = prev.some(existingMsg => existingMsg.id === message.id);
          const isDuplicateByContent = prev.some(existingMsg => 
            existingMsg.text === message.text && 
            existingMsg.userId === message.userId && 
            Math.abs(new Date(existingMsg.timestamp).getTime() - new Date(message.timestamp).getTime()) < 5000 // 5Ï¥à Ïù¥ÎÇ¥
          );
          
          const isDuplicate = isDuplicateById || isDuplicateByContent;
          
          console.log('üîç Message duplicate check:', { 
            messageId: message.id,
            text: message.text,
            userId: message.userId,
            isDuplicateById,
            isDuplicateByContent,
            isDuplicate,
            existingCount: prev.length,
            existingIds: prev.map(m => m.id).slice(-3) // ÏµúÍ∑º 3Í∞ú IDÎßå ÌëúÏãú
          });
          
          if (!isDuplicate) {
            console.log('‚úÖ Adding message to state');
            
            // Îã§Î•∏ ÏÇ¨Ïö©ÏûêÏùò Î©îÏãúÏßÄÏùº ÎïåÎßå ÏïåÎ¶º ÌëúÏãú
            if (message.userId !== currentUserRef.current?.id && !message.isSystemMessage) {
              // ÏÇ¨Ïö¥Îìú ÏïåÎ¶º
              playNotificationSound();
              
              // Îç∞Ïä§ÌÅ¨ÌÜ± ÏïåÎ¶º
              showDesktopNotification(`üí¨ ${message.userName}`, {
                body: message.text,
                tag: 'chat-message',
              });
            }
            
            const newMessages = [...prev, message];
            
            // Î©îÏãúÏßÄ Ïàò Ï†úÌïú (ÏµúÍ∑º 100Í∞úÎßå Ïú†ÏßÄ)
            const limitedMessages = newMessages.length > 100 ? newMessages.slice(-100) : newMessages;
            
            console.log('üìù Updated messages array length:', limitedMessages.length);
            return limitedMessages;
          } else {
            console.log('‚ö†Ô∏è Skipping duplicate message:', { id: message.id, text: message.text });
            return prev;
          }
        });
      });

      // ÏÇ¨Ïö©Ïûê ÏûÖÏû•
      channel.bind('user-joined', (user: User) => {
        logConnectionState('user_joined', `user ${user.name} (${user.id}) joined`);
        console.log('üëã User joined event:', user);
        console.log('üë• Current online users before:', onlineUsers.map(u => ({ id: u.id, name: u.name })));
        
        if (!isUserAlreadyOnline(user.id)) {
          console.log('‚úÖ Adding new user to list');
          setOnlineUsers(prev => {
            const newList = [...prev, user];
            console.log('üë• Updated online users:', newList.map(u => ({ id: u.id, name: u.name })));
            return newList;
          });
          
          // ÏûÖÏû• ÏïåÎ¶º Î©îÏãúÏßÄ Ï∂îÍ∞Ä
          const joinMessage: Message = {
            id: `join-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
            text: `${user.name}ÎãòÏù¥ Ï±ÑÌåÖÎ∞©Ïóê Ï∞∏Ïó¨ÌñàÏäµÎãàÎã§! üéâ`,
            userId: 'system',
            userName: 'System',
            userAvatar: '',
            timestamp: new Date().toISOString(),
            isSystemMessage: true
          };
          setMessages(prev => [...prev, joinMessage]);
        } else {
          console.log('‚ö†Ô∏è User already online, skipping');
        }
      });

      // ÏÇ¨Ïö©Ïûê Ìá¥Ïû•
      channel.bind('user-left', (user: User) => {
        logConnectionState('user_left', `user ${user.name} (${user.id}) left`);
        console.log('üëã User left event:', user);
        console.log('üë• Current online users before:', onlineUsers.map(u => ({ id: u.id, name: u.name })));
        
        setOnlineUsers(prev => {
          const newList = prev.filter(u => u.id !== user.id);
          console.log('üë• Updated online users after removal:', newList.map(u => ({ id: u.id, name: u.name })));
          return newList;
        });
        
        // Ìá¥Ïû• ÏïåÎ¶º Î©îÏãúÏßÄ Ï∂îÍ∞Ä
        const leaveMessage: Message = {
          id: `leave-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          text: `${user.name}ÎãòÏù¥ Ï±ÑÌåÖÎ∞©ÏùÑ ÎÇòÍ∞îÏäµÎãàÎã§. üëã`,
          userId: 'system',
          userName: 'System',
          userAvatar: '',
          timestamp: new Date().toISOString(),
          isSystemMessage: true
        };
        setMessages(prev => [...prev, leaveMessage]);
      });

      // ÌÉÄÏù¥Ìïë ÏãúÏûë Ïù¥Î≤§Ìä∏
      channel.bind('user-typing', (typingUser: TypingUser) => {
        console.log('‚å®Ô∏è RECEIVED user-typing event:', {
          typingUser,
          currentUserId: currentUserRef.current?.id,
          isOwnTyping: typingUser.id === currentUserRef.current?.id,
          typingSettingEnabled: notificationSettings.typing
        });
        
        // ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÏùò ÌÉÄÏù¥ÌïëÏùÄ Î¨¥Ïãú
        if (typingUser.id === currentUserRef.current?.id) {
          console.log('‚ö†Ô∏è Ignoring own typing event');
          return;
        }
        
        setTypingUsers(prev => {
          console.log('üìù Updating typing users state:', {
            previousUsers: prev.map(u => ({ id: u.id, name: u.name })),
            newTypingUser: { id: typingUser.id, name: typingUser.name }
          });

          // Ïù¥ÎØ∏ ÌÉÄÏù¥Ìïë Ï§ëÏù∏ ÏÇ¨Ïö©ÏûêÎäî ÏóÖÎç∞Ïù¥Ìä∏Îßå
          const existingIndex = prev.findIndex(user => user.id === typingUser.id);
          if (existingIndex >= 0) {
            console.log('üîÑ Updating existing typing user');
            const updated = [...prev];
            updated[existingIndex] = typingUser;
            return updated;
          }
          
          // ÏÉàÎ°úÏö¥ ÌÉÄÏù¥Ìïë ÏÇ¨Ïö©Ïûê Ï∂îÍ∞Ä
          console.log('‚ûï Adding new typing user');
          const newUsers = [...prev, typingUser];
          console.log('‚úÖ New typing users state:', newUsers.map(u => ({ id: u.id, name: u.name })));
          return newUsers;
        });

        // ÌÉÄÏù¥Ìïë ÏïåÎ¶º ÌëúÏãú (ÏÑ§Ï†ïÏù¥ ÏºúÏ†∏ ÏûàÏùÑ Îïå)
        if (notificationSettings.typing) {
          console.log(`üí¨ ${typingUser.name}ÎãòÏù¥ ÏûÖÎ†• Ï§ëÏûÖÎãàÎã§...`);
        }
      });

      // ÌÉÄÏù¥Ìïë Ï§ëÏßÄ Ïù¥Î≤§Ìä∏
      channel.bind('user-stopped-typing', (data: { userId: string }) => {
        console.log('‚å®Ô∏è RECEIVED user-stopped-typing event:', {
          stoppedUserId: data.userId,
          currentUserId: currentUserRef.current?.id,
          isOwnStopTyping: data.userId === currentUserRef.current?.id
        });
        
        setTypingUsers(prev => {
          console.log('üìù Removing user from typing state:', {
            previousUsers: prev.map(u => ({ id: u.id, name: u.name })),
            userToRemove: data.userId
          });

          const filteredUsers = prev.filter(user => user.id !== data.userId);
          console.log('‚úÖ Updated typing users after removal:', filteredUsers.map(u => ({ id: u.id, name: u.name })));
          return filteredUsers;
        });
      });

        logConnectionState('initialize_complete', 'all event bindings and channel setup completed for new instance');
      } else {
        console.log('üîÑ Skipping event binding for reused instance');
        logConnectionState('initialize_complete', 'reused instance setup completed');
        
        // Ïû¨ÏÇ¨Ïö©Îêú Ïù∏Ïä§ÌÑ¥Ïä§Ïùò Í≤ΩÏö∞ Ïó∞Í≤∞ ÏÉÅÌÉúÎ•º Í∞ïÏ†úÎ°ú Îã§Ïãú ÌôïÏù∏
        setTimeout(() => {
          checkConnectionStatus();
        }, 1000);
      }

    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Unknown error';
      logConnectionState('initialize_error', `error occurred: ${errorMsg}`);
      console.error('Error initializing Pusher:', error);
      setConnectionStatus('failed');
      setLastError(errorMsg);
      
      if (!isDisconnectingRef.current && connectionAttemptsRef.current < maxRetries) {
        attemptReconnect();
      }
    }
  }, [isUserAlreadyOnline, logConnectionState, startPeriodicTasks, syncWithServer, stopPeriodicTasks, checkConnectionStatus]);

  // Ïû¨Ïó∞Í≤∞ Ìï®Ïàò (Í∞úÏÑ†)
  const attemptReconnect = useCallback(() => {
    if (retryCount >= maxRetries || isDisconnectingRef.current) {
      const reason = retryCount >= maxRetries ? 'max retries reached' : 'manual disconnection';
      logConnectionState('reconnect_skipped', reason);
      setConnectionStatus('failed');
      setLastError('Max reconnection attempts reached');
      return;
    }

    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }

    const maxDelay = process.env.NODE_ENV === 'production' ? 30000 : 15000;
    const delay = Math.min(retryDelay * Math.pow(1.8, retryCount), maxDelay);
    
    logConnectionState('reconnecting', `attempt ${retryCount + 1}/${maxRetries} in ${delay}ms`);
    
    reconnectTimeoutRef.current = setTimeout(() => {
      if (!isDisconnectingRef.current && componentMountedRef.current) {
        logConnectionState('reconnect_execute', `attempt ${retryCount + 1}/${maxRetries}`);
        setRetryCount(prev => prev + 1);
        initializePusher();
      } else {
        logConnectionState('reconnect_skipped', 'component unmounted or disconnecting');
      }
    }, delay);
  }, [retryCount, initializePusher, logConnectionState]);

  // Pusher Ï†ïÎ¶¨ Ìï®Ïàò (Ïã±Í∏ÄÌÜ§ ÏÇ¨Ïö©) - React Strict Mode ÏïàÏ†Ñ
  const cleanupPusher = useCallback(() => {
    // Ïù¥ÎØ∏ Ï†ïÎ¶¨ Ï§ëÏù¥Í±∞ÎÇò Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÎã§Î©¥ Ï§ëÎ≥µ Ï†ïÎ¶¨ Î∞©ÏßÄ
    if (isDisconnectingRef.current || !isInitializedRef.current) {
      logConnectionState('cleanup_skipped', 'already disconnecting or not initialized');
      return;
    }
    
    logConnectionState('cleanup_started', 'manual cleanup initiated');
    isDisconnectingRef.current = true;
    isInitializedRef.current = false;
    
    // Ï¥àÍ∏∞Ìôî ID Î¨¥Ìö®Ìôî (ÏßÑÌñâ Ï§ëÏù∏ Ï¥àÍ∏∞Ìôî Î∞©ÏßÄ)
    initializationIdRef.current = null;
    
    // Ï£ºÍ∏∞Ï†Å ÏûëÏóÖ Ï§ëÏßÄ
    stopPeriodicTasks();
    
    // Í∏∞Ï°¥ Ï†ïÎ¶¨ ÌÉÄÏù¥Î®∏ Ï∑®ÏÜå
    if (cleanupTimeoutRef.current) {
      clearTimeout(cleanupTimeoutRef.current);
      cleanupTimeoutRef.current = null;
    }
    
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
      reconnectTimeoutRef.current = null;
    }
    
    // Î°úÏª¨ Î†àÌçºÎü∞Ïä§ Ï†ïÎ¶¨
    channelRef.current = null;
    pusherRef.current = null;
    currentUserRef.current = null;
    
    // Ïã±Í∏ÄÌÜ§ Ïù∏Ïä§ÌÑ¥Ïä§ Ìï¥Ï†ú
    releasePusherInstance();
    logConnectionState('cleanup', 'singleton instance released');
    
    setIsConnected(false);
    setConnectionStatus('disconnected');
    setLastError(null);
    connectionAttemptsRef.current = 0;
    
    // Ï†ïÎ¶¨ ÏôÑÎ£å ÌõÑ ÌîåÎûòÍ∑∏ Î¶¨ÏÖã (Í∞úÎ∞ú ÌôòÍ≤ΩÏóêÏÑúÎäî Îçî Îπ†Î•¥Í≤å)
    const resetDelay = process.env.NODE_ENV === 'development' ? 3000 : 2000;
    setTimeout(() => {
      isDisconnectingRef.current = false;
      logConnectionState('cleanup', 'cleanup completed, flag reset');
    }, resetDelay);
  }, [logConnectionState, stopPeriodicTasks]);

  // React Strict Mode ÏïàÏ†ïÌôîÎ•º ÏúÑÌïú ref
  const initializationIdRef = useRef<string | null>(null);
  const cleanupTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  useEffect(() => {
    // Í≥†Ïú†Ìïú Ï¥àÍ∏∞Ìôî ID ÏÉùÏÑ±
    const initId = `init-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    initializationIdRef.current = initId;
    
    // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú Ï¥àÍ∏∞Ìôî
    componentMountedRef.current = true;
    logConnectionState('component_mount', `component mounted, setting up pusher (${initId})`);
    
    // Í∏∞Ï°¥ Ï†ïÎ¶¨ ÌÉÄÏù¥Î®∏ Ï∑®ÏÜå
    if (cleanupTimeoutRef.current) {
      clearTimeout(cleanupTimeoutRef.current);
      cleanupTimeoutRef.current = null;
    }
    
    const initDelay = process.env.NODE_ENV === 'production' ? 2000 : 1000;
    const initTimer = setTimeout(() => {
      // ÌòÑÏû¨ Ï¥àÍ∏∞Ìôî IDÍ∞Ä Ïó¨Ï†ÑÌûà Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏ (React Strict Mode Î∞©ÏßÄ)
      if (initializationIdRef.current === initId && 
          componentMountedRef.current && 
          !isInitializedRef.current) {
        
        // Ïó∞Í≤∞ Ìï¥Ï†ú ÏÉÅÌÉúÎ•º Îçî Í¥ÄÎåÄÌïòÍ≤å Ï≤òÎ¶¨ (ÌôòÍ≤Ω Î¨¥Í¥Ä)
        if (isDisconnectingRef.current) {
          logConnectionState('component_mount', 'forcing reset of disconnecting state for stability');
          isDisconnectingRef.current = false;
        }
        
        if (!isDisconnectingRef.current) {
          logConnectionState('component_mount', `initializing pusher after delay (${initId})`);
          initializePusher();
        } else {
          logConnectionState('component_mount', `skipped - initialized: ${isInitializedRef.current}, disconnecting: ${isDisconnectingRef.current}`);
        }
      } else {
        logConnectionState('component_mount', `skipped - initialization cancelled (${initId} vs ${initializationIdRef.current})`);
      }
    }, initDelay);

    return () => {
      // Ï¥àÍ∏∞Ìôî ID Î¨¥Ìö®Ìôî
      if (initializationIdRef.current === initId) {
        initializationIdRef.current = null;
      }
      
      logConnectionState('component_unmount', `cleaning up (${initId})`);
      componentMountedRef.current = false;
      clearTimeout(initTimer);
      
      // ÌôòÍ≤ΩÏóê Í¥ÄÍ≥ÑÏóÜÏù¥ ÏßÄÏó∞Îêú Ï†ïÎ¶¨Î°ú ÏïàÏ†ïÏÑ± ÌôïÎ≥¥
      const cleanupDelay = process.env.NODE_ENV === 'production' ? 3000 : 2000;
      cleanupTimeoutRef.current = setTimeout(() => {
        // Îã§Î•∏ Ïª¥Ìè¨ÎÑåÌä∏ Ïù∏Ïä§ÌÑ¥Ïä§Í∞Ä Ï¥àÍ∏∞ÌôîÎêòÏßÄ ÏïäÏïòÎã§Î©¥ Ï†ïÎ¶¨ ÏßÑÌñâ
        if (!componentMountedRef.current && !isInitializedRef.current) {
          logConnectionState('cleanup_delayed', `proceeding with cleanup (${initId})`);
          cleanupPusher();
        } else {
          logConnectionState('cleanup_cancelled', `cleanup cancelled - component remounted (${initId})`);
        }
      }, cleanupDelay);
    };
  }, [initializePusher, cleanupPusher, logConnectionState]);

  // ÏàòÎèô Ïû¨Ïó∞Í≤∞ Ìï®Ïàò
  const reconnect = useCallback(() => {
    if (isDisconnectingRef.current) {
      logConnectionState('manual_reconnect', 'skipped - already disconnecting');
      return;
    }
    
    logConnectionState('manual_reconnect', 'initiated by user');
    setRetryCount(0);
    setLastError(null);
    connectionAttemptsRef.current = 0;
    isInitializedRef.current = false;
    initializePusher();
  }, [initializePusher, logConnectionState]);

  const sendMessage = async (message: string, user: User) => {
    try {
      console.log('üöÄ sendMessage called with:', { message, user });
      
      // Î™®Î∞îÏùº ÌôòÍ≤Ω Í∞êÏßÄ
      const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
      
      console.log('üì± Device info:', {
        isMobile,
        isIOS,
        userAgent: navigator.userAgent,
        platform: navigator.platform
      });
      
      // ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù Í∞ïÌôî
      if (!message || typeof message !== 'string' || message.trim().length === 0) {
        throw new Error('Invalid message: empty or non-string');
      }
      
      if (!user || !user.id || !user.name || !user.avatar) {
        throw new Error('Invalid user data: missing required fields');
      }

      if (message.length > 1000) {
        throw new Error('Message too long: maximum 1000 characters');
      }
      
      if (!isPusherConnected()) {
        const currentState = getConnectionState();
        console.log('‚ùå Not connected to Pusher:', currentState);
        logConnectionState('send_message', `failed - not connected, current state: ${currentState}`);
        throw new Error('Not connected to Pusher');
      }

      console.log('‚úÖ Pusher is connected, sending message to server');
      
      // ÏïàÏ†ÑÌïú Î©îÏãúÏßÄ ID ÏÉùÏÑ± (Î™®Î∞îÏùº ÌôòÍ≤Ω Í≥†Î†§)
      let messageId;
      try {
        if (typeof crypto !== 'undefined' && crypto.randomUUID) {
          messageId = `${Date.now()}-${crypto.randomUUID()}`;
        } else if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
          const array = new Uint32Array(2);
          crypto.getRandomValues(array);
          messageId = `${Date.now()}-${array[0]}-${array[1]}`;
        } else {
          messageId = `${Date.now()}-${Math.random().toString(36).substr(2, 12)}-${Math.random().toString(36).substr(2, 12)}`;
        }
      } catch (cryptoError) {
        console.warn('‚ö†Ô∏è Crypto API failed, using fallback:', cryptoError);
        messageId = `${Date.now()}-${Math.random().toString(36).substr(2, 12)}-${Math.random().toString(36).substr(2, 12)}`;
      }
      
      console.log('üÜî Generated message ID:', messageId);
      
      // ÏïàÏ†ÑÌïú ÌéòÏù¥Î°úÎìú ÏÉùÏÑ±
      const payload = {
        message: message.trim(),
        user: {
          id: user.id,
          name: user.name,
          avatar: user.avatar,
          joinedAt: user.joinedAt
        },
        messageId,
        // Î™®Î∞îÏùº ÌôòÍ≤Ω Ï†ïÎ≥¥ Ï∂îÍ∞Ä
        clientInfo: {
          isMobile,
          isIOS,
          userAgent: navigator.userAgent.substring(0, 100) // Í∏∏Ïù¥ Ï†úÌïú
        }
      };
      
      console.log('üì§ Sending to API...');
      
      // Î™®Î∞îÏùº ÌôòÍ≤ΩÏóêÏÑú Îçî Í∏¥ ÌÉÄÏûÑÏïÑÏõÉ Ï†ÅÏö©
      const timeoutDuration = isMobile ? 15000 : 10000; // Î™®Î∞îÏùº: 15Ï¥à, Îç∞Ïä§ÌÅ¨ÌÜ±: 10Ï¥à
      
      const controller = new AbortController();
      const timeoutId = setTimeout(() => {
        controller.abort();
      }, timeoutDuration);
      
      try {
        const response = await fetch('/api/pusher', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
          signal: controller.signal
        });
        
        clearTimeout(timeoutId);

        if (!response.ok) {
          let errorData;
          try {
            errorData = await response.json();
          } catch {
            try {
              errorData = await response.text();
            } catch {
              errorData = `HTTP ${response.status} ${response.statusText}`;
            }
          }
          console.error('‚ùå API response error:', errorData);
          throw new Error(`Server error (${response.status}): ${typeof errorData === 'string' ? errorData : JSON.stringify(errorData)}`);
        }
        
        const responseData = await response.json();
        console.log('‚úÖ API response success:', responseData);
        logConnectionState('send_message', 'success');
        
      } catch (fetchError) {
        clearTimeout(timeoutId);
        
        if (fetchError.name === 'AbortError') {
          console.error('‚ùå Request timeout after', timeoutDuration, 'ms');
          throw new Error(`Request timeout (${timeoutDuration/1000}s) - ÎÑ§Ìä∏ÏõåÌÅ¨Í∞Ä ÎäêÎ¶¨Í±∞ÎÇò ÏÑúÎ≤Ñ ÏùëÎãµÏù¥ ÏßÄÏó∞ÎêòÍ≥† ÏûàÏäµÎãàÎã§.`);
        }
        
        throw fetchError;
      }
      
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      console.error('‚ùå Error sending message:', {
        error: errorMessage,
        stack: error instanceof Error ? error.stack : undefined,
        isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
      });
      
      logConnectionState('send_message', `failed - ${errorMessage}`);
      
      // Î™®Î∞îÏùº ÌäπÌôî ÏóêÎü¨ Î©îÏãúÏßÄÎ°ú Î≥ÄÌôò
      if (errorMessage.includes('timeout') || errorMessage.includes('ÎÑ§Ìä∏ÏõåÌÅ¨')) {
        throw new Error('Î™®Î∞îÏùº ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò: Ïó∞Í≤∞Ïù¥ Î∂àÏïàÏ†ïÌï©ÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
      } else if (errorMessage.includes('Server error')) {
        throw new Error('ÏÑúÎ≤Ñ Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.');
      } else if (errorMessage.includes('Invalid')) {
        throw new Error('ÏûòÎ™ªÎêú Îç∞Ïù¥ÌÑ∞ÏûÖÎãàÎã§. ÌéòÏù¥ÏßÄÎ•º ÏÉàÎ°úÍ≥†Ïπ®Ìï¥Ï£ºÏÑ∏Ïöî.');
      } else if (errorMessage.includes('Not connected')) {
        throw new Error('Ïó∞Í≤∞Ïù¥ ÎÅäÏñ¥Ï°åÏäµÎãàÎã§. Ïù∏ÌÑ∞ÎÑ∑ Ïó∞Í≤∞ÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî.');
      }
      
      throw error;
    }
  };

  const joinChat = async (user: User) => {
    try {
      if (!isPusherConnected()) {
        const currentState = getConnectionState();
        logConnectionState('join_chat', `failed - not connected, current state: ${currentState}`);
        throw new Error('Not connected to Pusher');
      }

      // Ï±ÑÎÑê Íµ¨ÎèÖ ÏÉÅÌÉú ÌôïÏù∏
      if (!channelRef.current) {
        logConnectionState('join_chat', 'failed - channel not subscribed');
        throw new Error('Channel not subscribed');
      }

      // ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê ÏÑ§Ï†ï
      currentUserRef.current = user;
      console.log('‚úÖ Current user set in joinChat:', {
        userId: user.id,
        userName: user.name,
        userAvatar: user.avatar
      });

      // ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÎ•º Î°úÏª¨ÏóêÏÑú Ï†úÍ±∞ (Ïû¨ÏûÖÏû• Ïãú Ï§ëÎ≥µ Î∞©ÏßÄ)
      console.log('üîÑ Joining chat - removing current user from local list first');
      setOnlineUsers(prev => {
        const filtered = prev.filter(u => u.id !== user.id);
        console.log('üë• Local users after self-removal:', filtered.map(u => ({ id: u.id, name: u.name })));
        return filtered;
      });

      const response = await fetch('/api/pusher/user', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ action: 'join', user }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to join chat');
      }
      
      // ÏûÖÏû• ÌõÑ ÏÑúÎ≤ÑÏôÄ ÎèôÍ∏∞Ìôî
      setTimeout(syncWithServer, 2000);
      
      logConnectionState('join_chat', 'success');
    } catch (error) {
      console.error('Error joining chat:', error);
      throw error;
    }
  };

  const leaveChat = async (user: User) => {
    try {
      // Î°úÏª¨ ÏÉÅÌÉúÏóêÏÑú Ï¶âÏãú Ï†úÍ±∞
      setOnlineUsers(prev => prev.filter(u => u.id !== user.id));
      
      // ÌòÑÏû¨ ÏÇ¨Ïö©Ïûê Ï∞∏Ï°∞ Ï†ïÎ¶¨
      if (currentUserRef.current?.id === user.id) {
        currentUserRef.current = null;
      }
      
      if (isDisconnectingRef.current || !isPusherConnected()) {
        const currentState = getConnectionState();
        logConnectionState('leave_chat', `skipped API call - disconnecting: ${isDisconnectingRef.current}, connected: ${isPusherConnected()}, state: ${currentState}`);
        return;
      }

      const response = await fetch('/api/pusher/user', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ action: 'leave', user }),
      });

      if (!response.ok) {
        console.warn('Failed to leave chat via API, but local state already updated');
      }
      
      logConnectionState('leave_chat', 'success');
    } catch (error) {
      console.error('Error leaving chat:', error);
    }
  };

  // ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠
  const requestNotificationPermission = useCallback(async () => {
    if (!('Notification' in window)) {
      console.log('Ïù¥ Î∏åÎùºÏö∞Ï†ÄÎäî ÏïåÎ¶ºÏùÑ ÏßÄÏõêÌïòÏßÄ ÏïäÏäµÎãàÎã§.');
      return false;
    }

    console.log('üì± Current notification permission:', Notification.permission);

    if (Notification.permission === 'granted') {
      console.log('‚úÖ ÏïåÎ¶º Í∂åÌïúÏù¥ Ïù¥ÎØ∏ ÌóàÏö©ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.');
      return true;
    }

    if (Notification.permission !== 'denied') {
      try {
        console.log('üîî ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠ Ï§ë...');
        const permission = await Notification.requestPermission();
        console.log('üìù ÏïåÎ¶º Í∂åÌïú Í≤∞Í≥º:', permission);
        
        if (permission === 'granted') {
          console.log('‚úÖ ÏïåÎ¶º Í∂åÌïúÏù¥ ÌóàÏö©ÎêòÏóàÏäµÎãàÎã§!');
          // ÌÖåÏä§Ìä∏ ÏïåÎ¶º ÌëúÏãú
          showDesktopNotification('üéâ ÏïåÎ¶º ÏÑ§Ï†ï ÏôÑÎ£å!', {
            body: 'Ïù¥Ï†ú ÏÉà Î©îÏãúÏßÄÍ∞Ä ÎèÑÏ∞©ÌïòÎ©¥ ÏïåÎ¶ºÏùÑ Î∞õÏúºÏã§ Ïàò ÏûàÏäµÎãàÎã§.',
            tag: 'permission-granted',
          });
        }
        
        return permission === 'granted';
      } catch (error) {
        console.error('ÏïåÎ¶º Í∂åÌïú ÏöîÏ≤≠ Ïã§Ìå®:', error);
        return false;
      }
    }

    console.log('‚ùå ÏïåÎ¶º Í∂åÌïúÏù¥ Ï∞®Îã®ÎêòÏñ¥ ÏûàÏäµÎãàÎã§.');
    return false;
  }, []);

  // Îç∞Ïä§ÌÅ¨ÌÜ± ÏïåÎ¶º ÌëúÏãú
  const showDesktopNotification = useCallback((title: string, options?: NotificationOptions) => {
    console.log('üîî Attempting to show notification:', {
      title,
      desktopEnabled: notificationSettings.desktop,
      permission: Notification.permission,
      options
    });

    if (!notificationSettings.desktop) {
      console.log('‚ùå Î∏åÎùºÏö∞Ï†Ä ÏïåÎ¶ºÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.');
      return;
    }

    if (Notification.permission !== 'granted') {
      console.log('‚ùå ÏïåÎ¶º Í∂åÌïúÏù¥ ÏóÜÏäµÎãàÎã§. ÌòÑÏû¨ ÏÉÅÌÉú:', Notification.permission);
      return;
    }

    try {
      const notification = new Notification(title, {
        icon: '/images/cat.jpg',
        badge: '/images/cat.jpg',
        requireInteraction: false,
        ...options,
      });

      console.log('‚úÖ ÏïåÎ¶ºÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÌëúÏãúÎêòÏóàÏäµÎãàÎã§.');

      // ÌÅ¥Î¶≠ Ïãú Ï∞ΩÏúºÎ°ú Ìè¨Ïª§Ïä§
      notification.onclick = () => {
        window.focus();
        notification.close();
      };

      // 5Ï¥à ÌõÑ ÏûêÎèôÏúºÎ°ú Îã´Í∏∞
      setTimeout(() => {
        notification.close();
      }, 5000);

      return notification;
    } catch (error) {
      console.error('‚ùå ÏïåÎ¶º ÌëúÏãú Ïã§Ìå®:', error);
      return;
    }
  }, [notificationSettings.desktop]);

  // ÏÇ¨Ïö¥Îìú ÏïåÎ¶º Ïû¨ÏÉù
  const playNotificationSound = useCallback(() => {
    console.log('üîä Attempting to play notification sound:', {
      soundEnabled: notificationSettings.sound
    });

    if (!notificationSettings.sound) {
      console.log('‚ùå ÏÇ¨Ïö¥Îìú ÏïåÎ¶ºÏù¥ ÎπÑÌôúÏÑ±ÌôîÎêòÏñ¥ ÏûàÏäµÎãàÎã§.');
      return;
    }

    try {
      // Í∞ÑÎã®Ìïú ÏïåÎ¶ºÏùå ÏÉùÏÑ± (Web Audio API ÏÇ¨Ïö©)
      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
      
      const playCuteSound = (context: AudioContext) => {
        const playNote = (frequency: number, startTime: number, duration: number, volume: number = 0.3) => {
          const oscillator = context.createOscillator();
          const gainNode = context.createGain();
          
          oscillator.connect(gainNode);
          gainNode.connect(context.destination);
          
          oscillator.frequency.setValueAtTime(frequency, startTime);
          oscillator.type = 'sine';
          
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.02);
          gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
          
          oscillator.start(startTime);
          oscillator.stop(startTime + duration);
        };

        // ÎûúÎç§ÌïòÍ≤å Îã§ÏñëÌïú Í∑ÄÏó¨Ïö¥ Î©úÎ°úÎîî Ïû¨ÏÉù
        const melodies = [
          // Î©úÎ°úÎîî 1: ÎèÑ-ÎØ∏-ÏÜî-ÎèÑ (C-E-G-C) ÏÉÅÏäπ ÏïÑÎ•¥ÌéòÏßÄÏò§
          () => {
            const baseTime = context.currentTime;
            playNote(523.25, baseTime, 0.15, 0.25);        // ÎèÑ (C5)
            playNote(659.25, baseTime + 0.1, 0.15, 0.3);   // ÎØ∏ (E5)  
            playNote(783.99, baseTime + 0.2, 0.15, 0.35);  // ÏÜî (G5)
            playNote(1046.50, baseTime + 0.3, 0.25, 0.4);  // ÎèÑ (C6)
          },
          // Î©úÎ°úÎîî 2: ÎªêÍæ∏Í∏∞ ÏÜåÎ¶¨ (G-E-G-E)
          () => {
            const baseTime = context.currentTime;
            playNote(783.99, baseTime, 0.2, 0.3);          // ÏÜî (G5)
            playNote(659.25, baseTime + 0.15, 0.2, 0.3);   // ÎØ∏ (E5)
            playNote(783.99, baseTime + 0.3, 0.2, 0.3);    // ÏÜî (G5)
            playNote(659.25, baseTime + 0.45, 0.2, 0.3);   // ÎØ∏ (E5)
          },
          // Î©úÎ°úÎîî 3: Î∞òÏßùÎ∞òÏßù ÏûëÏùÄÎ≥Ñ ÏãúÏûë (C-C-G-G-A-A-G)
          () => {
            const baseTime = context.currentTime;
            playNote(523.25, baseTime, 0.12, 0.25);        // ÎèÑ (C5)
            playNote(523.25, baseTime + 0.12, 0.12, 0.25); // ÎèÑ (C5)
            playNote(783.99, baseTime + 0.24, 0.12, 0.3);  // ÏÜî (G5)
            playNote(783.99, baseTime + 0.36, 0.12, 0.3);  // ÏÜî (G5)
            playNote(880, baseTime + 0.48, 0.15, 0.35);    // Îùº (A5)
          },
          // Î©úÎ°úÎîî 4: ÎèÑÎ†àÎØ∏ÌååÏÜî ÏÉÅÏäπ
          () => {
            const baseTime = context.currentTime;
            playNote(523.25, baseTime, 0.1, 0.25);         // ÎèÑ (C5)
            playNote(587.33, baseTime + 0.1, 0.1, 0.25);   // Î†à (D5)
            playNote(659.25, baseTime + 0.2, 0.1, 0.3);    // ÎØ∏ (E5)
            playNote(698.46, baseTime + 0.3, 0.1, 0.3);    // Ìåå (F5)
            playNote(783.99, baseTime + 0.4, 0.2, 0.35);   // ÏÜî (G5)
          }
        ];
        
        // ÎûúÎç§ÌïòÍ≤å Î©úÎ°úÎîî ÏÑ†ÌÉù
        const randomMelody = melodies[Math.floor(Math.random() * melodies.length)];
        randomMelody();
        
        console.log('‚úÖ Í∑ÄÏó¨Ïö¥ ÏïåÎ¶ºÏùåÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ïû¨ÏÉùÎêòÏóàÏäµÎãàÎã§. üéµ');
      };

      // Î™®Î∞îÏùºÏóêÏÑú Ïò§ÎîîÏò§ Ïª®ÌÖçÏä§Ìä∏Í∞Ä suspended ÏÉÅÌÉúÏùº Ïàò ÏûàÏùå
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          console.log('üéµ Audio context resumed');
          playCuteSound(audioContext);
        });
      } else {
        playCuteSound(audioContext);
      }
    } catch (error) {
      console.warn('‚ùå ÏïåÎ¶ºÏùå Ïû¨ÏÉù Ïã§Ìå®:', error);
    }
  }, [notificationSettings.sound]);

  // ÌÉÄÏù¥Ìïë ÏãúÏûë - ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÎ•º Îß§Í∞úÎ≥ÄÏàòÎ°ú Î∞õÎèÑÎ°ù ÏàòÏ†ï
  const startTyping = useCallback(async (user?: User) => {
    const currentUser = user || currentUserRef.current;
    
    console.log('‚å®Ô∏è startTyping called:', {
      hasCurrentUser: !!currentUser,
      hasCurrentUserRef: !!currentUserRef.current,
      isConnected: isPusherConnected(),
      isAlreadyTyping: isTypingRef.current,
      currentUser: currentUser?.name,
      currentUserFull: currentUser,
      typingSettingEnabled: notificationSettings.typing,
      userFromParam: !!user,
      userFromRef: !!currentUserRef.current
    });

    if (!currentUser) {
      console.log('‚ùå No current user (neither param nor ref), cannot start typing');
      return;
    }

    if (!isPusherConnected()) {
      console.log('‚ùå Not connected to Pusher, cannot start typing');
      return;
    }

    if (isTypingRef.current) {
      console.log('‚ö†Ô∏è Already typing, skipping');
      return;
    }

    try {
      isTypingRef.current = true;
      console.log('üöÄ Sending typing start event to server...');
      
      const response = await fetch('/api/pusher/typing', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          action: 'start', 
          user: currentUser 
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();
      console.log('‚úÖ Typing start event sent successfully:', result);

      // ÌÉÄÏù¥Ìïë ÌÉÄÏûÑÏïÑÏõÉ ÏÑ§Ï†ï (3Ï¥à ÌõÑ ÏûêÎèôÏúºÎ°ú Ï§ëÏßÄ)
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
      }
      
      typingTimeoutRef.current = setTimeout(() => {
        console.log('‚è∞ Typing timeout reached, auto-stopping');
        stopTyping();
      }, 3000);

    } catch (error) {
      console.error('‚ùå Error starting typing:', error);
      isTypingRef.current = false;
    }
  }, []);

  // ÌÉÄÏù¥Ìïë Ï§ëÏßÄ - ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÎ•º Îß§Í∞úÎ≥ÄÏàòÎ°ú Î∞õÎèÑÎ°ù ÏàòÏ†ï
  const stopTyping = useCallback(async (user?: User) => {
    const currentUser = user || currentUserRef.current;
    
    console.log('‚å®Ô∏è stopTyping called:', {
      hasCurrentUser: !!currentUser,
      hasCurrentUserRef: !!currentUserRef.current,
      isConnected: isPusherConnected(),
      isCurrentlyTyping: isTypingRef.current,
      currentUser: currentUser?.name,
      userFromParam: !!user,
      userFromRef: !!currentUserRef.current
    });

    if (!currentUser) {
      console.log('‚ùå No current user (neither param nor ref), cannot stop typing');
      return;
    }

    if (!isPusherConnected()) {
      console.log('‚ùå Not connected to Pusher, cannot stop typing');
      return;
    }

    if (!isTypingRef.current) {
      console.log('‚ö†Ô∏è Not currently typing, skipping');
      return;
    }

    try {
      isTypingRef.current = false;
      console.log('üõë Sending typing stop event to server...');
      
      if (typingTimeoutRef.current) {
        clearTimeout(typingTimeoutRef.current);
        typingTimeoutRef.current = null;
      }

      const response = await fetch('/api/pusher/typing', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ 
          action: 'stop', 
          user: currentUser 
        }),
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      const result = await response.json();
      console.log('‚úÖ Typing stop event sent successfully:', result);

    } catch (error) {
      console.error('‚ùå Error stopping typing:', error);
    }
  }, []);

  // ÌÉÄÏù¥Ìïë ÏÇ¨Ïö©Ïûê Ï†ïÎ¶¨ (5Ï¥à Ïù¥ÏÉÅ ÏßÄÎÇú ÏÇ¨Ïö©Ïûê Ï†úÍ±∞)
  const cleanupTypingUsers = useCallback(() => {
    const now = new Date().getTime();
    setTypingUsers(prev => prev.filter(user => {
      const startTime = new Date(user.startedAt).getTime();
      return now - startTime < 5000; // 5Ï¥à Ïù¥ÎÇ¥
    }));
  }, []);

  // ÌÉÄÏù¥Ìïë Ï†ïÎ¶¨ ÌÉÄÏù¥Î®∏ ÏãúÏûë
  useEffect(() => {
    typingCleanupIntervalRef.current = setInterval(cleanupTypingUsers, 1000);
    
    return () => {
      if (typingCleanupIntervalRef.current) {
        clearInterval(typingCleanupIntervalRef.current);
      }
    };
  }, [cleanupTypingUsers]);

  // ÏïåÎ¶º ÏÑ§Ï†ï Î≥ÄÍ≤Ω
  const updateNotificationSettings = useCallback((settings: Partial<NotificationSettings>) => {
    setNotificationSettings(prev => {
      const newSettings = { ...prev, ...settings };
      
      // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóê Ï†ÄÏû•
      try {
        localStorage.setItem('chatNotificationSettings', JSON.stringify(newSettings));
        console.log('üîß Notification settings saved:', newSettings);
      } catch (error) {
        console.warn('Failed to save notification settings:', error);
      }
      
      return newSettings;
    });
  }, []);

  return {
    isConnected,
    connectionStatus,
    onlineUsers,
    messages,
    typingUsers,
    notificationSettings,
    sendMessage,
    joinChat,
    leaveChat,
    reconnect,
    retryCount,
    cleanupPusher,
    getConnectionState,
    getCurrentTransport,
    lastError,
    startTyping,
    stopTyping,
    requestNotificationPermission,
    showDesktopNotification,
    playNotificationSound,
    updateNotificationSettings,
  };
};
